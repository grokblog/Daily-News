"""
Multi-Identity Character Generator
===================================
Generate multiple unique human identities, each with many style variations.

Features:
- Generate unlimited unique people (different faces)
- Each person has their own identity folder
- Multiple outfits, poses, backgrounds per person
- Realistic photographic style
- Templates for various ethnicities, ages, genders

Author: Generated by Gemini
"""

import requests
import json
import re
import os
import uuid
import random
import time
from datetime import datetime
from pathlib import Path
from dataclasses import dataclass, asdict, field
from typing import Optional, List, Tuple, Dict
from enum import Enum


# ============================================================================
# CONFIGURATION
# ============================================================================

API_URL = "http://localhost:8017/v1/chat/completions"
API_KEY = None

# Output directories
OUTPUT_DIR = Path("multi_identities")
OUTPUT_DIR.mkdir(exist_ok=True)


# ============================================================================
# IDENTITY BUILDING BLOCKS
# ============================================================================

class Gender(Enum):
    MALE = "male"
    FEMALE = "female"

class AgeGroup(Enum):
    YOUNG_ADULT = "young adult in early 20s"
    MID_ADULT = "adult in mid 30s"
    MATURE = "mature adult in late 40s"
    SENIOR = "senior in 60s"

# Ethnic appearances with detailed features - ASIAN WOMEN ONLY (18-30 years)
ETHNICITIES = {
    "asian_east_chinese": {
        "name": "Chinese",
        "skin": "flawless fair to light skin with warm undertones",
        "eyes": "mesmerizing dark brown almond-shaped eyes",
        "hair": "luxurious straight silky black hair",
        "features": "stunningly beautiful refined features, high cheekbones, delicate nose, aesthetic perfection"
    },
    "asian_east_korean": {
        "name": "Korean",
        "skin": "perfect pale porcelain skin, glass skin texture",
        "eyes": "enchanting large dark brown eyes",
        "hair": "glossy straight dark brown or black hair",
        "features": "breathtakingly beautiful v-shaped face, dainty nose, idol-like visual elegance"
    },
    "asian_east_japanese": {
        "name": "Japanese",
        "skin": "flawless fair skin, clear complexion",
        "eyes": "large expressive dark eyes, long lashes",
        "hair": "silky smooth straight black hair",
        "features": "incredibly cute and beautiful, delicate refined features, kawai aesthetic, angelic face"
    },
    "asian_southeast_indonesian": {
        "name": "Indonesian",
        "skin": "glowing warm tan to golden brown skin",
        "eyes": "captivating large dark brown eyes",
        "hair": "flowing dark brown to black wavy hair",
        "features": "exotic stunning beauty, sweetest smile, gorgeous facial structure, miss universe aesthetic"
    },
    "asian_southeast_malaysian": {
        "name": "Malaysian",
        "skin": "radiant warm tan skin with golden hue",
        "eyes": "sparkling dark brown eyes",
        "hair": "voluminous dark wavy or straight hair",
        "features": "naturally gorgeous, elegant soft features, stunning friendly appearance"
    },
    "asian_southeast_thai": {
        "name": "Thai",
        "skin": "luminous light tan to golden skin",
        "eyes": "alluring dark brown almond eyes",
        "hair": "sleek straight black hair",
        "features": "strikingly beautiful, delicate sharp features, graceful and elegant top model look"
    },
    "asian_southeast_vietnamese": {
        "name": "Vietnamese",
        "skin": "pristine fair to light tan skin",
        "eyes": "dove-like dark brown almond eyes",
        "hair": "flowing straight silky black hair",
        "features": "classically beautiful, elegant refined features, ethereal graceful appearance"
    },
    "asian_southeast_filipino": {
        "name": "Filipino",
        "skin": "sun-kissed warm tan to light brown skin",
        "eyes": "beautiful expressive doe eyes",
        "hair": "thick dark wavy or straight hair",
        "features": "stunning mestiza beauty, defined features, radiant infectious smile"
    },
    "middle_eastern_arab": {
        "name": "Arab",
        "skin": "flawless olive to light tan skin",
        "eyes": "piercing dark brown or black captivating eyes",
        "hair": "thick luxurious dark brown or black hair",
        "features": "breathtakingly beautiful, sharp defined features, regal elegance, goddess-like appearance"
    },
    "south_asian_indian": {
        "name": "Indian",
        "skin": "radiant warm brown skin with golden glow",
        "eyes": "deep mesmerizing expressive eyes",
        "hair": "thick long lustrous black hair",
        "features": "features of a bollywood star, sharp nose, full lips, incredibly stunning traditional beauty"
    },
    "south_asian_pakistani": {
        "name": "Pakistani",
        "skin": "fair to luminous wheat complexion",
        "eyes": "hypnotic hazel or light brown eyes",
        "hair": "thick voluminous dark brown hair",
        "features": "strikingly gorgeous, sharp aristocratic features, elegant beauty"
    },
    "south_asian_bangladeshi": {
        "name": "Bangladeshi",
        "skin": "glowing warm tan to brown skin",
        "eyes": "deep soulful brown eyes",
        "hair": "long cascading dark black hair",
        "features": "soft breathtaking feminine beauty, sweet and elegant features"
    },
    "central_asian": {
        "name": "Central Asian",
        "skin": "porcelain fair to light tan skin",
        "eyes": "stunning hazel or green almond eyes",
        "hair": "silky dark brown or black hair",
        "features": "exotic unique beauty, perfect blend of east and west features, high fashion look"
    },
    "persian": {
        "name": "Persian/Iranian",
        "skin": "smooth fair olive skin",
        "eyes": "enchanting dark brown or green eyes",
        "hair": "thick shiny dark brown or black hair",
        "features": "legendary persian beauty, perfectly sculpted nose, defined thick brows, elegant"
    },
    "turkish": {
        "name": "Turkish",
        "skin": "flawless olive to fair skin",
        "eyes": "striking hazel or light brown eyes",
        "hair": "voluminous thick dark brown hair",
        "features": "stunning mediterranean beauty, sharp aesthetic features, captivating look"
    }
}

# Hair styles
HAIR_STYLES = {
    "female": [
        "long straight hair flowing past shoulders",
        "medium length wavy hair",
        "short bob haircut",
        "long curly voluminous hair",
        "elegant updo hairstyle",
        "ponytail tied back",
        "braided hair",
        "shoulder-length layered hair",
        "pixie cut short hair",
        "half-up half-down hairstyle"
    ],
    "male": [
        "short neat haircut",
        "medium length styled hair",
        "undercut modern hairstyle",
        "slicked back hair",
        "casual messy textured hair",
        "buzz cut short hair",
        "side-parted classic hair",
        "curly natural hair",
        "medium wavy hair",
        "fade haircut with styled top"
    ]
}

# Outfits/Clothing
OUTFITS = {
    "casual": [
        "casual white t-shirt and blue jeans",
        "comfortable hoodie and joggers",
        "casual polo shirt and chinos",
        "relaxed sweater and denim",
        "simple tank top and shorts",
        "casual button-up shirt untucked",
        "graphic tee and cargo pants",
        "cozy cardigan and leggings",
        "casual dress with sneakers",
        "athleisure wear"
    ],
    "formal": [
        "elegant business suit",
        "formal dress shirt and tie",
        "sophisticated blazer and dress pants",
        "elegant evening gown",
        "professional business attire",
        "formal tuxedo outfit",
        "classy cocktail dress",
        "smart casual office wear",
        "formal traditional attire",
        "luxury designer outfit"
    ],
    "professional": [
        "doctor white coat with stethoscope",
        "chef uniform with apron",
        "police officer uniform",
        "nurse medical scrubs",
        "firefighter gear",
        "business executive suit",
        "teacher professional attire",
        "scientist lab coat",
        "pilot uniform",
        "construction worker gear"
    ],
    "sporty": [
        "athletic workout clothes",
        "running gear with sneakers",
        "yoga outfit",
        "basketball jersey and shorts",
        "soccer uniform",
        "tennis outfit",
        "swimming attire",
        "cycling gear with helmet",
        "martial arts gi",
        "gym training outfit"
    ],
    "creative": [
        "artistic bohemian outfit",
        "trendy streetwear",
        "vintage retro clothing",
        "edgy leather jacket outfit",
        "colorful festival wear",
        "minimalist modern outfit",
        "punk rock style",
        "hippie inspired clothing",
        "gothic dark fashion",
        "preppy classic style"
    ]
}

# Poses and expressions (Full Body)
POSES = [
    # WALKING (Active & Dynamic)
    "Full body wide shot, walking towards camera with confidence",
    "Long shot walking sideways, passing by, full profile view",
    "Full body shot strolling casually, looking around",
    "Wide angle shot walking away from camera, showing back of outfit",
    "Full body shot hurrying/walking fast, dynamic motion blur on feet",
    "Long shot walking down a path or street, fully visible",
    
    # STANDING (Static & Posed)
    "Full body shot standing straight comfortable posture, facing forward",
    "Wide shot standing with weight on one leg, relaxed pose",
    "Full body shot standing and leaning against a generic wall or railing",
    "Long shot standing waiting patiently, hands in pockets",
    "Full body shot standing with crossed arms, confident look",
    "Wide angle standing pose, looking upwards or at sky",
    "Full body shot standing and checking phone held in hand",
    "Long shot standing profile view, looking to the side",
    "Full body fashion stance, one hand on hip, standing tall",
    
    # SITTING (Versatile - naturally integrated into environment)
    "Full body shot sitting on a bench or chair, legs crossed",
    "Wide shot sitting on the ground or floor, relaxed posture",
    "Full body shot sitting on steps or casual ledge, looking at camera",
    "Long shot sitting casually with legs stretched out",
    "Full body shot sitting on a stool or high seat, one leg resting",
    "Wide shot sitting comfortably, resting elbows on knees"
]

# Backgrounds/Settings
SETTINGS = [
    # INDOOR - Home & Living
    "cozy modern living room with sunlight",
    "luxury bright modern kitchen",
    "minimalist bedroom with big window",
    "elegant hallway in luxury house",
    "indoor balcony with city view",
    
    # INDOOR - Public & Social
    "trendy coffee shop interior with warm lighting",
    "busy shopping mall walkway",
    "quiet library with rows of books",
    "modern art gallery with white walls",
    "luxury hotel lobby with chandeliers",
    "upscale restaurant interior",
    "supermarket aisle with colorful products",
    "airport terminal waiting area",
    "subway station platform",
    
    # INDOOR - Work & Studio
    "clean professional studio white background",
    "modern office open plan workspace",
    "coworking space with glass walls",
    "artist studio with creative clutter",
    "fashion boutique fitting area",
    
    # OUTDOOR - Urban & City
    "busy urban city street with skyscrapers",
    "quiet suburban neighborhood street",
    "charming european old town street",
    "city rooftop with skyline view",
    "pedestrian crossing in modern city",
    "neon lit street at night",
    "urban concrete stairs or plaza",
    "outside a modern glass building",
    "graffiti art wall in alleyway",
    
    # OUTDOOR - Nature & Leisure
    "peaceful green park with big trees",
    "beautiful beach with blue ocean",
    "golden hour field with tall grass",
    "forest path with filtered sunlight",
    "flowering garden with colorful blooms",
    "lakeside wooden pier",
    "botanical garden glasshouse exterior",
    "mountain landscape background",
    "sunny poolside with blue water",
    
    # OUTDOOR - Specific Vibes
    "outdoor cafe seating area",
    "amusement park with colorful lights",
    "sports court or stadium background",
    "historic architecture monument",
    "bridge with city view in background"
]

# Lighting conditions
LIGHTING = [
    "natural soft daylight",
    "golden hour warm sunlight",
    "professional studio lighting",
    "dramatic side lighting",
    "soft diffused overcast light",
    "bright sunny day",
    "indoor ambient lighting",
    "neon urban night lighting",
    "candlelight warm glow",
    "backlit rim lighting"
]


# ============================================================================
# DATA CLASSES
# ============================================================================

@dataclass
class Identity:
    """Represents a unique person/identity"""
    id: str
    name: str
    gender: str
    age_group: str
    ethnicity: str
    base_appearance: str
    unique_features: str  # What makes this person unique
    style_keywords: str
    reference_image_url: Optional[str] = None
    reference_image_path: Optional[str] = None
    created_at: str = ""
    variations_count: int = 0
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
    
    def get_identity_dir(self) -> Path:
        """Get the directory for this identity's images"""
        safe_name = self.name.lower().replace(" ", "_")
        dir_path = OUTPUT_DIR / f"{self.id}_{safe_name}"
        dir_path.mkdir(exist_ok=True)
        return dir_path
    
    def get_base_prompt(self) -> str:
        """Generate base prompt for this identity"""
        return f"""A {self.age_group} {self.ethnicity} {self.gender}. {self.base_appearance}. 
Unique features: {self.unique_features}. 
Style: {self.style_keywords}"""
    
    def save(self):
        """Save identity to JSON"""
        dir_path = self.get_identity_dir()
        filepath = dir_path / "identity.json"
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(asdict(self), f, indent=2, ensure_ascii=False)
    
    @classmethod
    def load(cls, filepath: Path) -> 'Identity':
        """Load identity from JSON"""
        with open(filepath, 'r', encoding='utf-8') as f:
            data = json.load(f)
        return cls(**data)


# ============================================================================
# LOGGING
# ============================================================================

class Logger:
    @staticmethod
    def header(text: str):
        print(f"\n{'â•' * 60}")
        print(f"ğŸ¨ {text.upper()}")
        print(f"{'â•' * 60}")
    
    @staticmethod
    def step(text: str):
        print(f"â”œâ”€ {text}")
    
    @staticmethod
    def success(text: str, **details):
        print(f"â”‚  â”œâ”€ âœ“ {text}")
        for key, value in details.items():
            val_str = str(value)
            if len(val_str) > 60:
                val_str = val_str[:60] + "..."
            print(f"â”‚  â”‚  â”œâ”€ {key}: {val_str}")
    
    @staticmethod
    def error(text: str, error: str = None):
        print(f"â”‚  â”œâ”€ âœ— {text}")
        if error:
            print(f"â”‚  â”‚  â””â”€ error: {str(error)[:80]}")
    
    @staticmethod
    def info(key: str, value):
        val_str = str(value)
        if len(val_str) > 50:
            val_str = val_str[:50] + "..."
        print(f"â”‚  â”‚  â”œâ”€ {key}: {val_str}")
    
    @staticmethod
    def progress(current: int, total: int, text: str = ""):
        pct = (current / total) * 100
        bar_len = 20
        filled = int(bar_len * current / total)
        bar = "â–ˆ" * filled + "â–‘" * (bar_len - filled)
        print(f"â”‚  [{bar}] {current}/{total} ({pct:.0f}%) {text}")

log = Logger()


# ============================================================================
# API FUNCTIONS
# ============================================================================

def generate_image(prompt: str, retries: int = 3) -> Optional[str]:
    """Generate image from prompt"""
    headers = {"Content-Type": "application/json"}
    if API_KEY:
        headers["Authorization"] = f"Bearer {API_KEY}"

    payload = {
        "model": "grok-imagine-0.9",
        "messages": [{"role": "user", "content": [{"type": "text", "text": prompt}]}]
    }

    for attempt in range(1, retries + 1):
        try:
            response = requests.post(API_URL, headers=headers, json=payload, timeout=120)
            response.raise_for_status()
            result = response.json()

            if "choices" in result and len(result["choices"]) > 0:
                content = result["choices"][0]["message"]["content"]
                
                patterns = [
                    r'!\[Generated Image\]\((http://localhost:8017/images/[^)]+)\)',
                    r'src="(http://localhost:8017/images/[^"]+)"',
                    r'(http://localhost:8017/images/[^\s\)\"]+)',
                ]
                
                for pattern in patterns:
                    match = re.search(pattern, content)
                    if match:
                        return match.group(1).rstrip('"')
                
        except Exception as e:
            if attempt < retries:
                time.sleep(2)
    
    return None


def edit_image(prompt: str, image_url: str, retries: int = 3) -> Optional[str]:
    """Edit image with reference"""
    headers = {"Content-Type": "application/json"}
    if API_KEY:
        headers["Authorization"] = f"Bearer {API_KEY}"

    payload = {
        "model": "grok-4.1-thinking",
        "messages": [{
            "role": "user",
            "content": [
                {"type": "text", "text": prompt},
                {"type": "image_url", "image_url": {"url": image_url}}
            ]
        }]
    }

    for attempt in range(1, retries + 1):
        try:
            response = requests.post(API_URL, headers=headers, json=payload, timeout=180)
            response.raise_for_status()
            result = response.json()

            if "choices" in result and len(result["choices"]) > 0:
                content = result["choices"][0]["message"]["content"]
                
                patterns = [
                    r'!\[Generated Image\]\((http://localhost:8017/images/[^)]+\.jpg)\)',
                    r'src="(http://localhost:8017/images/[^"]+\.jpg)"',
                    r'(http://localhost:8017/images/[^\s\)\"]+\.jpg)',
                ]
                
                for pattern in patterns:
                    match = re.search(pattern, content)
                    if match:
                        return match.group(1).rstrip('"')
                
        except Exception as e:
            if attempt < retries:
                time.sleep(2)
    
    return None


def download_image(url: str, output_path: Path) -> bool:
    """Download image from URL"""
    try:
        response = requests.get(url, stream=True, timeout=60)
        response.raise_for_status()
        with open(output_path, 'wb') as f:
            for chunk in response.iter_content(chunk_size=8192):
                f.write(chunk)
        return True
    except:
        return False


# ============================================================================
# IDENTITY GENERATOR
# ============================================================================

class MultiIdentityGenerator:
    """Generate multiple unique identities with variations"""
    
    def __init__(self):
        self.identities: Dict[str, Identity] = {}
        self._load_existing_identities()
    
    def _load_existing_identities(self):
        """Load all existing identities"""
        for dir_path in OUTPUT_DIR.iterdir():
            if dir_path.is_dir():
                identity_file = dir_path / "identity.json"
                if identity_file.exists():
                    try:
                        identity = Identity.load(identity_file)
                        self.identities[identity.id] = identity
                    except:
                        pass
    
    def create_identity(
        self,
        name: str,
        gender: str = "female",
        age_group: str = "young adult in early 20s",
        ethnicity_key: str = "asian_southeast",
        custom_features: str = "",
        hair_style: str = ""
    ) -> Identity:
        """
        Create a new unique identity.
        
        Args:
            name: Name for this identity
            gender: "male" or "female"
            age_group: Age description
            ethnicity_key: Key from ETHNICITIES dict
            custom_features: Additional unique features
            hair_style: Specific hair style
        
        Returns:
            Identity object
        """
        log.header(f"Creating Identity: {name}")
        
        identity_id = str(uuid.uuid4())[:8]
        
        # Build appearance from ethnicity
        eth = ETHNICITIES.get(ethnicity_key, ETHNICITIES["asian_southeast_indonesian"])
        
        # Random or specified hair
        if not hair_style:
            hair_list = HAIR_STYLES.get(gender, HAIR_STYLES["female"])
            hair_style = random.choice(hair_list)
        
        # Build base appearance
        base_appearance = f"{eth['skin']}, {eth['eyes']}, {hair_style}, {eth['features']}"
        
        # Unique features (what makes this person distinct)
        if not custom_features:
            unique_options = [
                "stunningly beautiful smile, perfect facial symmetry",
                "breathtaking natural beauty, mesmerizing gaze",
                "flawlessly elegant features, radiant complexion",
                "gorgeous top model aesthetic, striking presence",
                "angelic beautiful face, charming expression",
                "extraordinarily attractive, magnetic beauty",
                "perfect visual aesthetic, stunningly gorgeous",
                "timeless elegant beauty, flawless appearance"
            ]
            custom_features = random.choice(unique_options)
        
        # Style keywords for realism
        style_keywords = "photorealistic, astounding beauty, masterpiece portrait, professional photography, natural lighting, high resolution, detailed skin texture, realistic human proportions, DSLR quality, 8K"
        
        identity = Identity(
            id=identity_id,
            name=name,
            gender=gender,
            age_group=age_group,
            ethnicity=eth['name'],
            base_appearance=base_appearance,
            unique_features=custom_features,
            style_keywords=style_keywords
        )
        
        identity.save()
        self.identities[identity_id] = identity
        
        log.success("Identity created", id=identity_id, name=name)
        log.info("Ethnicity", eth['name'])
        log.info("Features", custom_features[:50])
        
        return identity
    
    def create_random_identity(self, name: str = None) -> Identity:
        """Create a random identity - FEMALE ASIAN ONLY (18-30 years)"""
        
        log.step("Enforcing STRICT Random Constraints: Asian Female, 18-30 years")
        
        # FIXED: Female only
        gender = "female"
        
        # Age groups: 18-30 years old only
        age_groups = [
            "young woman aged 18",
            "young woman aged 19",
            "young woman aged 20",
            "young woman in early 20s",
            "young woman aged 22",
            "young woman aged 23",
            "young woman aged 24",
            "young woman in mid 20s",
            "young woman aged 26",
            "young woman aged 27",
            "young woman aged 28",
            "young woman in late 20s",
            "young woman aged 30"
        ]
        age = random.choice(age_groups)
        
        # Random Asian ethnicity
        ethnicity = random.choice(list(ETHNICITIES.keys()))
        
        # Generate random Asian female name if not provided
        if not name:
            # Asian female first names by region
            asian_female_names = {
                "chinese": ["Mei Lin", "Xiao Wei", "Li Na", "Jing", "Yan", "Hui", "Xue", "Ling", "Fang", "Ying"],
                "korean": ["Min Ji", "Soo Yeon", "Ji Eun", "Yuna", "Hana", "Minji", "Soojin", "Jiyeon", "Eunji", "Nara"],
                "japanese": ["Yuki", "Sakura", "Hana", "Aiko", "Mika", "Yumi", "Rin", "Saki", "Mai", "Kana"],
                "indonesian": ["Siti", "Dewi", "Putri", "Ayu", "Sri", "Wulan", "Ratna", "Indah", "Kartika", "Bunga"],
                "malaysian": ["Nurul", "Aisyah", "Siti", "Fatimah", "Nur", "Amira", "Hana", "Liyana", "Aida", "Zara"],
                "thai": ["Nong", "Ploy", "Fah", "Nok", "Pim", "May", "Nan", "Joy", "Bua", "Dao"],
                "vietnamese": ["Linh", "Ngoc", "Thao", "Trang", "Phuong", "Mai", "Lan", "Ha", "Huong", "Diem"],
                "filipino": ["Maria", "Ana", "Rose", "Grace", "Joy", "Angel", "Divine", "Princess", "Jasmine", "Pearl"],
                "arab": ["Fatima", "Aisha", "Maryam", "Layla", "Noor", "Sara", "Hana", "Yasmin", "Amira", "Lina"],
                "indian": ["Priya", "Anika", "Devi", "Lakshmi", "Meera", "Pooja", "Neha", "Shreya", "Kavya", "Aaradhya"],
                "pakistani": ["Ayesha", "Fatima", "Zara", "Aliya", "Hira", "Sana", "Nadia", "Mahnoor", "Anum", "Zainab"],
                "persian": ["Shirin", "Yasaman", "Setareh", "Parisa", "Nazanin", "Leila", "Mina", "Roxana", "Azita", "Golnar"],
                "turkish": ["Elif", "Zeynep", "Ayse", "Fatma", "Emine", "Merve", "Busra", "Nur", "Esra", "Selin"]
            }
            
            # Map ethnicity key to name category
            name_map = {
                "asian_east_chinese": "chinese",
                "asian_east_korean": "korean",
                "asian_east_japanese": "japanese",
                "asian_southeast_indonesian": "indonesian",
                "asian_southeast_malaysian": "malaysian",
                "asian_southeast_thai": "thai",
                "asian_southeast_vietnamese": "vietnamese",
                "asian_southeast_filipino": "filipino",
                "middle_eastern_arab": "arab",
                "south_asian_indian": "indian",
                "south_asian_pakistani": "pakistani",
                "south_asian_bangladeshi": "indian",  # Use Indian names
                "central_asian": "persian",
                "persian": "persian",
                "turkish": "turkish"
            }
            
            name_category = name_map.get(ethnicity, "indonesian")
            name = random.choice(asian_female_names.get(name_category, asian_female_names["indonesian"]))
        
        return self.create_identity(
            name=name,
            gender=gender,
            age_group=age,
            ethnicity_key=ethnicity
        )
    
    def generate_reference(self, identity: Identity) -> Optional[str]:
        """Generate the reference portrait for an identity"""
        log.header(f"Generating Reference: {identity.name}")
        
        prompt = f"""Create a photorealistic portrait photograph of:

{identity.get_base_prompt()}

Requirements:
- Head and shoulders portrait view
- Looking directly at camera
- Neutral natural expression with slight smile
- Clean simple background (studio white or light gray)
- Professional lighting, flattering angles
- Ultra high quality realistic photograph
- NOT anime, NOT cartoon, NOT 3D render
- Real human being photograph quality"""
        
        log.step("Generating portrait...")
        log.info("Prompt", prompt[:100])
        
        image_url = generate_image(prompt)
        
        if image_url:
            output_path = identity.get_identity_dir() / "reference.jpg"
            
            if download_image(image_url, output_path):
                identity.reference_image_url = image_url
                identity.reference_image_path = str(output_path)
                identity.save()
                
                log.success("Reference generated", path=str(output_path))
                return image_url
        
        log.error("Failed to generate reference")
        return None
    
    def generate_variation(
        self,
        identity: Identity,
        outfit: str = None,
        pose: str = None,
        setting: str = None,
        lighting: str = None
    ) -> Optional[Tuple[str, Path]]:
        """
        Generate a variation of the identity with different outfit/pose/setting.
        """
        if not identity.reference_image_url:
            log.error("No reference image for this identity")
            return None
        
        # Use random if not specified
        outfit = outfit or random.choice(sum(OUTFITS.values(), []))
        pose = pose or random.choice(POSES)
        setting = setting or random.choice(SETTINGS)
        lighting = lighting or random.choice(LIGHTING)
        
        prompt = f"""Generate a new photograph of THE EXACT SAME PERSON shown in the reference image.

This is the SAME person - MUST have identical face, features, and identity:
{identity.get_base_prompt()}

New scene details:
- Outfit: {outfit}
- Pose/Action: {pose}
- Setting/Background: {setting}
- Lighting: {lighting}

    CRITICAL REQUIREMENTS:
    - EXTREMELY IMPORTANT: FULL BODY LONG SHOT (Wide Angle)
    - MUST SHOW HEAD TO TOES (Shoes must be clearly visible)
    - Do NOT crop the feet. Do NOT crop the head.
    - Camera must be far back enough to capture the entire person.
    - Vertical aspect ratio (Full Page).
    - FULL LENGTH fashion photography style.
    - SAME person, SAME face, SAME identity as reference
    - Keep exact facial features, skin tone, face shape
    - Only change outfit, pose, and background
    - Photorealistic quality, NOT cartoon or anime
    - Professional photography style"""
        
        new_url = edit_image(prompt, identity.reference_image_url)
        
        if new_url:
            identity.variations_count += 1
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"var_{identity.variations_count:03d}_{timestamp}.jpg"
            output_path = identity.get_identity_dir() / filename
            
            if download_image(new_url, output_path):
                identity.save()
                return new_url, output_path
        
        return None
    
    def generate_outfit_series(
        self,
        identity: Identity,
        outfit_category: str = "casual",
        count: int = 10,
        delay: float = 1.5
    ) -> List[Tuple[str, Path]]:
        """Generate multiple images with different outfits from a category"""
        
        log.header(f"Outfit Series: {identity.name}")
        
        outfits = OUTFITS.get(outfit_category, OUTFITS["casual"])
        count = min(count, len(outfits))
        
        log.step(f"Generating {count} {outfit_category} outfit variations")
        
        results = []
        
        for i, outfit in enumerate(outfits[:count], 1):
            log.progress(i, count, outfit[:30])
            
            result = self.generate_variation(
                identity,
                outfit=outfit,
                setting="clean professional studio white background"
            )
            
            if result:
                results.append(result)
                log.success(f"Image {i}", outfit=outfit[:40])
            else:
                log.error(f"Image {i} failed")
            
            if i < count:
                time.sleep(delay)
        
        return results
    
    def generate_lifestyle_series(
        self,
        identity: Identity,
        count: int = 20,
        delay: float = 1.5
    ) -> List[Tuple[str, Path]]:
        """Generate lifestyle photos in various settings"""
        
        log.header(f"Lifestyle Series: {identity.name}")
        log.step(f"Generating {count} lifestyle images")
        
        results = []
        
        for i in range(count):
            log.progress(i + 1, count)
            
            result = self.generate_variation(identity)  # All random
            
            if result:
                results.append(result)
            
            if i < count - 1:
                time.sleep(delay)
        
        log.success(f"Complete: {len(results)}/{count} images")
        return results
    
    def generate_professional_series(
        self,
        identity: Identity,
        delay: float = 1.5
    ) -> List[Tuple[str, Path]]:
        """Generate professional/occupation photos"""
        
        log.header(f"Professional Series: {identity.name}")
        
        results = []
        
        for i, outfit in enumerate(OUTFITS["professional"], 1):
            log.progress(i, len(OUTFITS["professional"]), outfit[:30])
            
            result = self.generate_variation(
                identity,
                outfit=outfit,
                pose="professional confident pose at work",
                setting="relevant professional workplace setting"
            )
            
            if result:
                results.append(result)
            
            time.sleep(delay)
        
        return results
    
    def batch_create_identities(
        self,
        count: int = 5,
        images_per_identity: int = 10,
        delay: float = 1.5
    ) -> Dict[str, List[Tuple[str, Path]]]:
        """
        Create multiple identities and generate variations for each.
        
        Args:
            count: Number of identities to create
            images_per_identity: Number of images per identity
            delay: Delay between API calls
        
        Returns:
            Dict mapping identity ID to list of (url, path) tuples
        """
        log.header(f"Batch Creating {count} Identities")
        
        all_results = {}
        
        for i in range(count):
            print(f"\n{'â”€' * 60}")
            print(f"ğŸ§‘ IDENTITY {i + 1}/{count}")
            print(f"{'â”€' * 60}")
            
            # Create random identity
            identity = self.create_random_identity()
            
            # Generate reference
            ref = self.generate_reference(identity)
            
            if ref:
                # Generate variations
                results = self.generate_lifestyle_series(
                    identity,
                    count=images_per_identity,
                    delay=delay
                )
                all_results[identity.id] = results
            else:
                log.error("Failed to create reference, skipping")
            
            if i < count - 1:
                time.sleep(delay)
        
        # Summary
        print(f"\n{'â•' * 60}")
        print("ğŸ“Š BATCH COMPLETE")
        print(f"{'â•' * 60}")
        print(f"   Identities created: {len(all_results)}")
        total_images = sum(len(v) for v in all_results.values())
        print(f"   Total images: {total_images}")
        print(f"   Output folder: {OUTPUT_DIR}")
        print(f"{'â•' * 60}\n")
        
        return all_results
    
    def list_identities(self) -> List[Identity]:
        """List all identities"""
        return list(self.identities.values())
    
    def get_identity(self, identity_id: str) -> Optional[Identity]:
        """Get identity by ID"""
        return self.identities.get(identity_id)


# ============================================================================
# INTERACTIVE MENU
# ============================================================================

def interactive_menu():
    """Interactive menu for multi-identity generation"""
    
    print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘       ğŸ­ MULTI-IDENTITY GENERATOR                          â•‘
â•‘       Create Unique People with Many Variations            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    """)
    
    gen = MultiIdentityGenerator()
    
    while True:
        # Show existing identities
        identities = gen.list_identities()
        
        print(f"\nğŸ“ Existing Identities: {len(identities)}")
        for i, identity in enumerate(identities, 1):
            has_ref = "âœ“" if identity.reference_image_url else "âœ—"
            print(f"   {i}. [{identity.id}] {identity.name} ({identity.ethnicity}) - {identity.variations_count} images (ref: {has_ref})")
        
        print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  MENU OPTIONS                                              â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  1. Create NEW random identity                             â•‘
â•‘  2. Create CUSTOM identity                                 â•‘
â•‘  3. BATCH create multiple identities                       â•‘
â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â•‘
â•‘  4. Select existing identity & generate variations         â•‘
â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â•‘
â•‘  0. Exit                                                   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""")
        
        try:
            choice = input("Pilih opsi: ").strip()
            
            if choice == "0":
                print(f"\nğŸ‘‹ Bye! Images saved in: {OUTPUT_DIR}")
                break
            
            elif choice == "1":
                # Create random identity
                name = input("Nama (kosong = random): ").strip() or None
                identity = gen.create_random_identity(name)
                
                ref = gen.generate_reference(identity)
                if ref:
                    count = int(input("Berapa variasi gambar? (1-50): ").strip() or "10")
                    gen.generate_lifestyle_series(identity, count=min(count, 50))
            
            elif choice == "2":
                # Create custom identity
                identity = create_custom_identity(gen)
                if identity:
                    ref = gen.generate_reference(identity)
                    if ref:
                        count = int(input("Berapa variasi gambar? (1-50): ").strip() or "10")
                        gen.generate_lifestyle_series(identity, count=min(count, 50))
            
            elif choice == "3":
                # Batch create
                num_people = int(input("Berapa orang/identitas? (1-20): ").strip() or "5")
                imgs_each = int(input("Berapa gambar per orang? (1-30): ").strip() or "10")
                
                num_people = min(max(1, num_people), 20)
                imgs_each = min(max(1, imgs_each), 30)
                
                total = num_people * imgs_each
                print(f"\nâš ï¸  Total gambar: {total}")
                confirm = input("Lanjutkan? (y/n): ").strip().lower()
                
                if confirm == 'y':
                    gen.batch_create_identities(num_people, imgs_each)
            
            elif choice == "4":
                # Select existing and generate
                if not identities:
                    print("âŒ Tidak ada identitas. Buat dulu!")
                    continue
                
                idx = int(input(f"Pilih nomor identitas (1-{len(identities)}): ").strip()) - 1
                if 0 <= idx < len(identities):
                    identity = identities[idx]
                    
                    if not identity.reference_image_url:
                        print("Generating reference first...")
                        gen.generate_reference(identity)
                    
                    print(f"""
Opsi untuk {identity.name}:
  1. Lifestyle series (random)
  2. Outfit series (pilih kategori)
  3. Professional series
  4. Custom single image
""")
                    sub = input("Pilih: ").strip()
                    
                    if sub == "1":
                        count = int(input("Berapa gambar? ").strip() or "10")
                        gen.generate_lifestyle_series(identity, count=count)
                    elif sub == "2":
                        print("Kategori: casual, formal, professional, sporty, creative")
                        cat = input("Pilih kategori: ").strip() or "casual"
                        count = int(input("Berapa gambar? ").strip() or "10")
                        gen.generate_outfit_series(identity, cat, count)
                    elif sub == "3":
                        gen.generate_professional_series(identity)
                    elif sub == "4":
                        outfit = input("Outfit: ").strip()
                        pose = input("Pose: ").strip()
                        setting = input("Setting: ").strip()
                        gen.generate_variation(identity, outfit, pose, setting)
                        print("âœ“ Done!")
                        
        except KeyboardInterrupt:
            print("\n\nğŸ‘‹ Bye!")
            break
        except Exception as e:
            print(f"\nâŒ Error: {e}")
            continue


def create_custom_identity(gen: MultiIdentityGenerator) -> Optional[Identity]:
    """Create custom identity via interactive input"""
    print("\nğŸ†• CREATE CUSTOM IDENTITY")
    print("â”€" * 40)
    
    try:
        name = input("Nama: ").strip()
        if not name:
            name = "Custom Person"
        
        print("\nGender: male / female")
        gender = input("Gender: ").strip().lower() or "female"
        
        print("\nAge: young adult, mid 30s, late 40s, etc")
        age = input("Age: ").strip() or "young adult in mid 20s"
        
        print("\nEthnicity options:")
        for key, val in ETHNICITIES.items():
            print(f"  - {key}: {val['name']}")
        ethnicity = input("Ethnicity key: ").strip() or "asian_southeast_indonesian"
        
        print("\nUnique features (dimples, freckles, etc):")
        features = input("Features: ").strip()
        
        return gen.create_identity(
            name=name,
            gender=gender,
            age_group=age,
            ethnicity_key=ethnicity,
            custom_features=features
        )
        
    except KeyboardInterrupt:
        return None


# ============================================================================
# MAIN
# ============================================================================

if __name__ == "__main__":
    import sys
    
    if len(sys.argv) > 1:
        arg = sys.argv[1]
        
        if arg == "--batch":
            people = int(sys.argv[2]) if len(sys.argv) > 2 else 5
            images = int(sys.argv[3]) if len(sys.argv) > 3 else 10
            gen = MultiIdentityGenerator()
            gen.batch_create_identities(people, images)
            
        elif arg == "--help" or arg == "-h":
            print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘       ğŸ­ MULTI-IDENTITY GENERATOR                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Generate multiple unique human identities with many variations.

USAGE:
  python multi_identity_generator.py           # Interactive menu
  python multi_identity_generator.py --batch 5 10   # 5 people, 10 images each

FEATURES:
  - 8 ethnicity templates
  - 10+ hair styles per gender
  - 50+ outfit options (5 categories)
  - 20 poses
  - 20 backgrounds
  - 10 lighting conditions

Each identity gets:
  - Own folder with all images
  - Reference portrait
  - Unlimited variations

OUTPUT: multi_identities/
""")
        else:
            print(f"Unknown option: {arg}")
            print("Use --help for usage")
    else:
        interactive_menu()
